<!DOCTYPE html>
<html lang="en-us">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Memory Virtualization</title>
        <link rel="stylesheet" href=/assets/css/styles.css>
    </head>
    <body>
        <div class="l-flex-container">
            <div class="l-small-column">
                <nav>
    <ul>
        <li><a href="">Home</a></li>
        
            <li>
                <a href="/topics/01_resource.html">
                    Resource Sharing
                </a>
            </li>
        
            <li>
                <a href="/topics/02_processes.html">
                    More About Processes
                </a>
            </li>
        
            <li>
                <a href="/topics/03_lde.html">
                    Limited Direct Execution
                </a>
            </li>
        
            <li>
                <a href="/topics/04_scheduling.html">
                    Scheduling
                </a>
            </li>
        
            <li>
                <a href="/topics/05_threads.html">
                    Threads and Concurrency
                </a>
            </li>
        
            <li>
                <a href="/topics/06_locks.html">
                    Locks
                </a>
            </li>
        
            <li>
                <a href="/topics/07_condition.html">
                    Condition Variables
                </a>
            </li>
        
            <li>
                <a href="/topics/08_problems.html">
                    Concurrency Problems
                </a>
            </li>
        
            <li>
                <a href="/topics/09_memory.html">
                    Memory Virtualization
                </a>
            </li>
        
    </ul>
</nav>

            </div><!-- .l-small-column -->
            <div class="l-large-column">
                <header>
    <h1>Marcus's Operating System Notes</h1>
</header>

                <main><h1 id="memory-virtualization">Memory Virtualization</h1>

<h2 id="memory-and-processes">Memory and Processes</h2>

<p>We want to have many processes in memory at the same time. How do we allocate space for each process in an efficient manner?</p>

<p>One requirement of memory management is safety. We don’t want a bug in one program to cause problems in another. A <strong>segmentation fault</strong> can occur when a program tries to access memory outside its own boundaries. Transparency is another requirement of memory management. Processes “shouldn’t require particular physical memory bits.” The third requirement is that resources can be exhausted and we need a sort of “safety valve” for when the memory requirements exceed the amount of physical memory.</p>

<h2 id="virtual-addressing">Virtual Addressing</h2>

<p>The <strong>memory-management unit</strong> (MMU) translates the virtual address to the physical address so that only the OS knows the physical address. (A “core dumped” error message means there is no corresponding physical address.) Even the CPU doesn’t know the physical address. Remember that each process gets its own virtual address space with its own space for code, data, heap and stack. Each process has the illusion of having the whole memory, but these are shadows on the cave wall.</p>

<p>If each process has 16KB of memory, the minimum virtual address is 0, and the maximum address is (16 × 1024) - 1. The code starts at 0 and the heap starts just after and grows to the larger addresses. The stack starts at the highest address and “grows” to the lower address.</p>

<h2 id="the-algorithms">The Algorithms</h2>

<h3 id="base-and-bounds">Base and Bounds</h3>

<p>In <strong>base and bounds</strong>, there are two registers on the CPU: one is “base” and the other is “bounds”. The “base” is where the memory segment begins and the “bounds” is the allowed size of the memory. They are on the PCB for the process. The algorithm is simple:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Let physical address = virtual address + base.
If virtual address &lt; 0 or virtual address ≥ bounds:
    Trap to kernel.
</code></pre></div></div>

<p>We can change the base register to move processes in memory.</p>

<p>The operating system maintains a <strong>free list</strong> of available memory spaces. When a process starts, the OS searches for an appropriate spot and assigns the process. When a process is terminated, the free list is updated. If the OS detects that the items in the free list is contiguous, it can be compacted into a single entry in the list. The alternate name for this algorithm is “dynamic relocation” because the “OS can move process data when not running” that process.</p>

<p>Base and bounds needs only two registers, so the hardware requirements are low, and the algorithm is computationally simple for sure. Now what are the disadvantages? One problem is that the fixed amount of memory allocated may leave too much unused free space. Another is that “growing a process is expensive or impossible” because of the requirements of moving it. There is also “[n]o way to share code or data.”</p>

<h3 id="segmentation">Segmentation</h3>

<p><strong>Segmentation</strong> gives each address space three portions: code, stack, and heap. Each will have its own base and bounds for six total registers. Each portion need not be contiguous in physical memory. They can be separate, but virtual memory is still addressed as if the portions were contiguous. All this makes address translation a bit more complicated.</p>

<p>Here, we address the disadvantage of base and bounds in that this algorithm allows for better sharing of memory. However, it “requires translation hardware, which could limit performance” and fragmentation becomes “a real problem.”</p>

<h3 id="paging">Paging</h3>

<p>Modern operating systems utilize <strong>paging</strong>, in which memory is divided into “pages” of fixed size. This cuts down on wasted space. For each process, there is a <strong>page table</strong> that maps “virtual pages to physical <strong>page frames</strong>.” Each process takes up multiple pages in memory. Virtual pages and page frames are the exact same size in memory. Page frames need not be contiguous in physical memory.</p>

<p>The typical page size is 4KB. This has been determined to be the best size by experience.</p>

<p>A virtual address is composed of a virtual page number (VPN) as well as an offset. The page table maps a VPN to a page frame number (PFN) or physical page number (PPN). The table is just an array and the VPN is actually just the index of the array. A page table entry (PTE) is an element in the page table. The offset value must be checked to ensure it does not go out of bounds. If it does, this is a segmentation fault.</p>

<p>Paging allows for the easy allocation of memory. There is also “no need to track the direction” of the heap or stack growth. However, paging can cause “internal fragmentation,” i.e., the “process may not use memory in multiples of a page.” Another problem is that the page table is itself stored in memory, so there is an amount of “memory reference overhead” involved with retrieving it and the page table can take up quite a bit of memory. In a 32-bit system, each page table can be up to 4MB!</p>

<p>So the page tables are too big. What should we do? We can make the pages larger, which reduces the number of pages; however, this means internal fragmentation becomes an even bigger problem. One thing we can do is “only map the portion memory that is actually being used.” We can use a <strong>two-level page table</strong> but modern operating systems can use up to <em>six</em> levels. Rather than pointing to a page frame, the first pointer of a virtual address points to a master page table, which points to <em>a secondary page table</em>, which provides a page frame. Each level of a multi-level page table is itself divided into pages. The master page table itself ends up being only a single page.</p>

<p>Multi-level page tables trade space for time because the address translation across multiple levels takes more time. The solution to this is to use a <strong>translation lookaside buffer</strong> (TLB) which is managed by the MMU and is a part of the hardware itself. It caches translations and this speeds things up <em>significantly</em>. The TLB translates virtual page numbers into PTEs rather than physical addresses. Even though only 32-128 PTEs are stored on the TLB, these PTEs can make up <em>99%</em> of translations. If there is a miss, the PTE will be stored directly on the TLB <em>and then the TLB will be queried for that entry again</em>. This means a PTE that’s on the TLB has to be “evicted.” Selecting an unlucky PTE depends on the replacement policy.</p>
</main>
                <footer>
    <p>
    The information on this page should be distributed freely and must be used
    for educational purposes only. While this website is wholly the creation of
    Marcus Bartlett, all content is from Professor Juhau Hu's TCSS 422
    class at University of Washington Tacoma during the quarter of Spring 2022.
    Some course content is therefore adapted from the course textbook
    <a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">Operating Systems: Three
        Easy Pieces
    </a> by Remzi and Andrea Arpaci-Dusseau
    The header image was created by
    <a href="https://unsplash.com/photos/jXd2FSvcRr8">Umberto</a>. Anything that
    appears in quotation marks without citations is taken from Juhua's
    lecture slides. Please do not send the copyright police after me.
    </p>
    <p>
        If you see any problem with this website, no matter how trivial, please
        email me at
        <a href="mailto:mabartlett@hotmail.com">mabartlett@hotmail.com</a>.
    </p>
</footer>

            </div><!-- l-large-column -->
        </div><!-- .l-flex-container -->
    </body>
</html>
